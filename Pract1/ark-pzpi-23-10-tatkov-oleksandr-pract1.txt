МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ


ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ 
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмна інженерія»






ДОПОВІДЬ


для дисципліни «Аналіз та рефакторинг коду»

на тему «Рекомендації від компанії Microsoft до написання коду (C#)»






Виконав:                                                                                   Прийняв:

ст. гр. ПЗПІ-23-10                                                                    ст. викл Сокорчук І.П

Татьков О.С










Харків 2025

Зафіксовані зміни.

№
Дата
Версія звіту
Опис змін та 
виправлень
1
11.10.2025
0.1
Створення 
титульної 
сторінки звіту, 
мети роботи.
2
12.10.2025
0.2
Написання 
коду, вивчення 
джерел.
3
13.10.2025
0.3
Написання коду 
та тексту для 
запис у розділ 
Хід роботи.
4
14.10.2025
0.4
Написано 
висновки, 
список 
використаних 
джерел.
5
16.01.2025
0.5
Створення 
додатків.


1.Мета роботи


	Закріпити знання з основ програмування мовою C# шляхом 
ознайомлення з ключовими принципами та рекомендаціями написання 
якісного, зрозумілого й підтримуваного коду. Сформувати навички 
використання стандартів оформлення програмного коду, дотримання правил 
іменування, структуризації програм та застосування практик, що підвищують 
надійність, читабельність і ефективність програмних рішень.
     						
2.Хід роботи

	Почнемо з того, що написання коду — це не лише процес створення 
програми, яка працює, а й відповідальність за те, наскільки зручно буде 
іншим людям або навіть самому автору через деякий час цей код читати, 
підтримувати і розвивати. Саме тому виникає потреба дотримуватись певних 
правил та рекомендацій. Хороший код — це не той, який просто запускається 
без помилок, а той, який легко зрозуміти, модифікувати і розширювати. 
Дотримання стандартів допомагає уникати хаосу в проєкті, зменшує 
ймовірність виникнення помилок і значно спрощує командну роботу.
	При написанні коду мовою C# важливо пам’ятати, що стиль і структура 
програми повинні бути узгоджені. Якщо кожен програміст у команді буде 
писати на власний розсуд, то з часом проєкт перетвориться на заплутану 
систему, в якій важко орієнтуватися. Чіткі правила щодо іменування змінних, 
методів і класів роблять програму зрозумілою навіть для тих, хто бачить її 
вперше. Використання відступів, правильне форматування і дотримання 
логіки побудови блоків коду роблять його візуально приємним і легким для 
аналізу.
	Крім зручності читання, гарний код дозволяє значно швидше знаходити 
і виправляти помилки, а також мінімізує ризик виникнення нових. Якщо 
методи є занадто великими або виконують надто багато завдань одночасно, це 
ускладнює відстеження логіки. Тому важливо дотримуватися принципу 
розбиття на дрібніші, зрозумілі частини, які мають одну чітку функцію. Це 
робить програму більш гнучкою і дозволяє повторно використовувати вже 
написані фрагменти.
	Ще однією важливою причиною дотримання правил є довготривала 
перспектива. Програмне забезпечення часто розвивається роками, і код, який 
сьогодні здається очевидним, через кілька місяців без відповідного стилю 
може бути абсолютно незрозумілим навіть його автору. Добре 
структурований і охайно написаний код з коментарями та передбачуваною 
логікою значно полегшує його підтримку.
	Отже, розглянемо загальні рекомендації, які допомагають зробити код 
більш зрозумілим, підтримуваним і надійним.
	Перш за все слід пам’ятати про використання осмислених імен для 
класів, методів і змінних. Якщо ж у коді зустрічаються абстрактні чи 
випадкові назви, то навіть проста конструкція стає заплутаною. У C# 
загальноприйнято використовувати стиль PascalCase для назв класів, 
інтерфейсів, методів і констант, а camelCase для параметрів та локальних 
змінних. Приватні поля зазвичай починають із символу підкреслення, що 
дозволяє їх легко відрізняти від інших ідентифікаторів. Дотримання єдиного 
підходу до найменувань робить код передбачуваним і зрозумілим навіть для 
тих, хто бачить його вперше [додаток В.1].
     Ще однією важливою рекомендацією є уникнення оголошення полів як 
public. Якщо відкрити прямий доступ до внутрішніх змінних, це порушує 
принцип інкапсуляції та створює ризики неконтрольованої зміни даних 
ззовні. Натомість використання властивостей (properties) дозволяє зберігати 
дані під контролем, додавати перевірки і валідацію значень. Це забезпечує 
більшу безпеку, надійність і гнучкість коду, оскільки логіку роботи з даними 
завжди можна змінити, не змінюючи структуру класу [додаток В.2].
     Окрему увагу слід приділити магічним числам. Використання числових 
літералів без пояснення ускладнює розуміння, адже програміст, який читає 
код, не знає, що саме означає конкретне число. Коли ж такі значення винесені 
у константи або перерахування з осмисленими назвами, стає зрозумілою не 
тільки логіка програми, а й сенс самих значень. Це спрощує читання коду, 
знижує ймовірність помилок і дозволяє легко змінювати ключові параметри 
програми в одному місці, не переглядаючи увесь код [додаток В.3].
	Не менш важливим є і стиль форматування. У C# поширеним є 
використання чотирьох пробілів для відступів замість табуляції. Такий підхід 
робить код однаково виглядним у різних середовищах розробки і редакторах. 
Використання стилю Allman для розміщення фігурних дужок підвищує 
читабельність, оскільки відкриваюча дужка завжди знаходиться на новому 
рядку, чітко відокремлюючи логічні блоки. Також слід дотримуватись 
правила одного рядка для одного оператора та одного оголошення на рядок, 
щоб код був впорядкованим і легким для сприйняття [додаток В.4].
	Дуже важливо також подбати про супровідність і зрозумілість коду за 
допомогою коментарів. Для публічних класів і методів у C# рекомендується 
використовувати XML-коментарі. Завдяки тегу summary можна коротко 
пояснити призначення класу чи методу, що особливо допомагає під час 
командної розробки або при створенні документації. Такі коментарі 
підхоплює IntelliSense у Visual Studio, і розробники отримують підказки 
прямо під час роботи з кодом. Це не лише спрощує розуміння, а й формує 
хорошу практику документування, що відповідає офіційним рекомендаціям 
Microsoft [додаток В.5].
	Не менш значущою є правильна обробка винятків. Ловити винятки слід 
лише тоді, коли дійсно можна їх коректно обробити. Використання 
загального типу Exception є помилкою, адже воно маскує конкретні проблеми. 
Краще вказувати специфічний виняток, наприклад, DivideByZeroException, і 
при цьому не забувати після логування повторно пробросити його, щоб не 
приховати інші потенційні помилки. Для ресурсів, які потребують очищення, 
рекомендується застосовувати конструкцію using, що автоматично викликає 
метод Dispose. Це зменшує ризик витоку ресурсів і робить код безпечнішим 
[додаток В.6].
	Ще одним фундаментальним підходом є дотримання принципів SOLID. 
Це п’ять базових принципів об’єктно-орієнтованого програмування, які 
роблять архітектуру програмного забезпечення зрозумілою, гнучкою і 
масштабованою. Наприклад, принцип єдиної відповідальності передбачає, що 
кожен клас має виконувати лише одну задачу, і саме це робить код більш 
передбачуваним і простим у підтримці. Інші принципи, такі як відкритість до 
розширення, сегрегація інтерфейсів чи інверсія залежностей, допомагають 
будувати систему, яка витримує зміни та розширення без втрати стабільності 
[додаток В.7].
	Не варто забувати й про зручність читання коду при роботі з рядками. 
Замість громіздкої конкатенації краще використовувати інтерполяцію, яка 
дозволяє прямо в рядку підставляти значення змінних. Такий підхід робить 
код коротшим, чистішим і зрозумілішим навіть для недосвідченого 
програміста [додаток В.8].
     Ще одна корисна практика стосується використання ключового слова 
var. Його слід застосовувати тоді, коли тип змінної очевидний із правої 
частини виразу. Це робить код більш компактним і сучасним, але водночас 
зловживати var не варто, адже втрачається наочність. Якщо з коду 
незрозуміло, який саме тип повертається, краще явно його вказати [додаток 
В.9].
	Важливе місце займає і асинхронне програмування. У сучасних 
застосунках, де активно використовуються операції введення-виведення, 
асинхронність дозволяє не блокувати виконання і робить програму більш 
відгуковою. Використання ключових слів async і await допомагає коректно 
реалізувати цю модель, зберігаючи код чистим і зрозумілим. Це особливо 
актуально при роботі з мережевими запитами чи файлами, коли затримки 
неминучі [додаток В.10].
	Завершальним аспектом є логічна організація коду. Великі проєкти 
потребують впорядкованості, і тут на допомогу приходять простори імен. 
Вони дозволяють групувати споріднені класи разом і відображати їхню 
структуру у відповідних папках. Зрозуміле групування спрощує навігацію в 
коді, дозволяє швидше орієнтуватися у проєкті та підтримувати архітектуру в 
охайному стані. Коли кожен клас має своє місце і логічну назву, підтримка й 
розвиток програмного забезпечення стають набагато простішими [додаток 
В.11].
	З метою наочності розглянемо приклад вирішення конкретної задачі 
джуніор-розробником і порівняємо його з підходом, який застосував би більш 
досвідчений middle або senior-розробник:
	Контекст задачі: Припустимо ,потрібно реалізувати метод, який 
отримує список об’єктів Order і повертає суму Total для всіх тих замовлень, 
де дата замовлення (OrderDate) — в поточному місяці.
     Класс Order: [додаток В.12].
     Код джуна: [додаток В.13].
Код досвідченого програміста: [додаток В.14].
	Сеньйорський код відрізняється від джуновського насамперед підходом 
до задачі. Джун пише так, щоб воно просто працювало тут і зараз: він бере 
список замовлень, перевіряє місяць і додає суми. Проблема в тому, що такий 
підхід не враховує нюанси — наприклад, що потрібно звіряти не лише місяць, 
а й рік, що список може бути порожнім чи взагалі null, що DateTime.Now 
ускладнить тестування, бо час жорстко зашитий у коді. Це означає, що при 
найменшій зміні умов або у випадку нетипових даних такий код може давати 
неправильний результат або ламатися. Сеньйор, на відміну від цього, думає 
не тільки про “щоб запрацювало”, а й про підтримуваність і розширюваність. 
Він додає абстракцію для отримання часу, щоб код можна було протестувати 
незалежно від системної дати, перевіряє вхідні аргументи, щоб уникнути 
неочікуваних помилок, і робить логіку більш точною — враховує і місяць, і 
рік. Крім того, сеньйор пише так, щоб інший розробник легко зрозумів, що 
відбувається: зрозумілі назви змінних, відсутність “магічних чисел”, 
використання LINQ або чітких циклів. Головна різниця в тому, що 
джуновський код зосереджений на вирішенні конкретної задачі “тут і зараз”, а 
сеньйорський — на створенні рішення, яке легко підтримувати, перевіряти, 
адаптувати і яке не зламається від дрібної зміни умов.
 
Висновки

	Під час підготовки матеріалів доповіді було закріплено практичні 
навички написання якісного коду мовою C#. Основним результатом стало 
засвоєння принципів створення зрозумілого та підтримуваного програмного 
забезпечення. Було вивчено стандарти іменування змінних, методів і класів, 
принципи інкапсуляції через використання властивостей, методи усунення 
"магічних чисел" за допомогою констант, а також правила форматування коду 
та документування за допомогою XML-коментарів. Особливу увагу 
приділено порівнянню підходів початківця та досвідченого розробника, що 
наочно продемонструвало важливість тестованості коду, перевірки вхідних 
даних та точності логіки. Опанування цих навичок є необхідним для 
створення професійних, надійних та довгострокових програмних рішень.
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     Список використаних джерел
     
1.	Microsoft Docs. C# Coding Conventions [Електронний ресурс]. – Режим 
доступу: https://learn.microsoft.com/en-
us/dotnet/csharp/fundamentals/coding-style/coding-conventions – Дата 
звернення: 25.09.2025.
2.	Microsoft Docs. Exception Handling (C# Programming Guide) 
[Електронний ресурс]. – Режим доступу: https://learn.microsoft.com/en-
us/dotnet/csharp/fundamentals/exceptions/ – Дата звернення: 25.09.2025.
3.	Microsoft Docs. Asynchronous programming with async and await 
[Електронний ресурс]. – Режим доступу: https://learn.microsoft.com/en-
us/dotnet/csharp/asynchronous-programming/ – Дата звернення: 
25.09.2025.
4.	Мартін Р. Чистий код. Створення, аналіз та рефакторинг / перекл. з 
англ. – К.: Видавництво Старого Лева, 2021. – 464 с.
5.	Мартін Р. Принципи, шаблони та методики гнучкої розробки (Agile 
Software Development, Principles, Patterns, and Practices) / перекл. з англ. 
– К.: Діалектика, 2019. – 720 с.
6.	Troelsen A., Japikse P. Pro C# 10 with .NET 6. – Apress, 2022. – 1500 p.
     Skeet J. C# in Depth. – 4th ed. – Manning Publications, 2019. – 528 p.
 
Додаток А
     
     Посилання на відеоролик на YouTube: https://youtu.be/qZDT3XVRjA0
     
     Хронологічний опис відеозапису:
	0:00 – Вступ.
          0:39 – Інструменти для статичного аналізу коду. 
          1:20 – Інструменти форматування та автоматизації. 
          1:56 – Дотримуйтеся правил іменування. 
          2:17 – Використовуйте властивості замість публічних полів. 
          2:36 – Уникайте «магічних чисел». 
          3:06 – Форматуйте код правильно. 
          3:29 – Документуйте публічні типи та члени. 
          3:46 – Правильно обробляйте винятки. 
          4:01 – Дотримуйтеся принципів SOLID. 
          4:27 – Використовуйте інтерполяцію рядків 
          4:42 – Використовуйте var там, де тип очевидний 
          5:06 – Використовуйте асинхронне програмування (async/await) 
          5:20 – Організуйте код у логічній структурі 
          5:35 – Junior code vs Senior code: Завдання 
          6:14 – Junior code vs Senior code: Коментарі 
          6:48 – Невеликий висновок.
     
     
     
     
     
     
     
     
     

Додаток Б
Перелік слайдів презентації

 
Рисунок Б.1 – Титульний аркуш.

 
Рисунок Б.2 – Вступ.





 
Рисунок Б.3 –Дотримуйтеся правил іменування.

 
Рисунок Б.4 –Використовуйте властивості замість публічних полів.




 
Рисунок Б.5 –Уникайте ”Магічних чисел”.

 
Рисунок Б.6 – Форматуйте код правильно.






 
Рисунок Б.7 –Уникайте ”Магічних чисел”.

 
Рисунок Б.8 – Правильно обробляйте винятки.






 
Рисунок Б.9 – Дотримуйтесь принципів SOLID.

 
Рисунок Б.10 – Використовуйте інтерполяцію рядків.








 
Рисунок Б.11 – Використовуйте var там, де тип очевидний.

 
Рисунок Б.12 – Використовуйте асинхронне програмування.




 
Рисунок Б.13 – Організуйте код у логічні структури.

 
Рисунок Б.14 – Уникайте дублювання коду.






 
Рисунок Б.15 – Junior Code vs Senior Code: Завдання.

 
Рисунок Б.16 – Junior Code vs Senior Code: Коментарі.

 
Рисунок Б.17 – Перелік використаних джерел.


















 
Додаток В

В.1 Приклад класу з правильним іменуванням
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V1.cs
public class OrderProcessor
{
    private int _orderCount;       // приватне поле в camelCase з префіксом '_'
    public void ProcessOrder(Order order)   // метод у PascalCase
    {
        // ...
    }
}
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V2.cs
В.2 Інкапсуляція через властивості
public class Person
{
private string _name;  // приватне поле
public string Name     // публічна властивість
{
get => _name;
set
{
if (string.IsNullOrEmpty(value))
throw new ArgumentException("Ім'я не може бути порожнім");
_name = value;
}
}
}

В.3 Уникнення магічних чисел
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V3.cs

// Поганий приклад: невідомо, що означає '365' без контексту
int days = 365;

// Кращий приклад: константа пояснює значення
const int DaysPerYear = 365;
int days = DaysPerYear;

В.4 Стиль форматування Allman
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V4.cs
public class Calculator
{
    public int Add(int a, int b)
    {
        // Умова з відступом і дужками Allman
        if (a > 0 && b > 0)
        {
            return a + b;
        }
        return 0;
    }
}

В.5 XML-коментарі для документації
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V5.cs
/// <summary>
/// Клас, що виконує обробку замовлень.
/// </summary>
public class OrderProcessor
{
    /// <summary>
    /// Обробляє вказане замовлення.
    /// </summary>
    /// <param name="order">Об'єкт замовлення для обробки.</param>
    public void ProcessOrder(Order order)
    {
        // ...
    }
}

В.6 Коректна обробка винятків
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V6.cs
     
try
{
    int result = 10 / divisor;
}
catch (DivideByZeroException ex)
{
    Console.WriteLine("Помилка: ділення на нуль.");
    throw; // повторно пробросити виняток після логування
}

В.7 Принцип єдиної відповідальності
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V7.cs

public class UserCreator   // відповідає за створення користувачів
{
    public User CreateUser(string name) { /* ... */ }
}

public class UserRepository  // відповідає за збереження користувача в БД
{
    public void SaveUser(User user) { /* ... */ }
}

В.8 Інтерполяція рядків
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V8.cs

string firstName = "Ivan";
int age = 30;
Console.WriteLine($"Name: {firstName}, Age: {age}");
В.9 Раціональне використання var
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V9.cs

var numbers = new List<int>(); // тип List<int> очевидний
// Протилежний приклад (не ясно, який тип повертає GetData()):
// var data = GetData(); 
В.10 Асинхронне програмування
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V10.cs

public async Task<string> DownloadAsync(string url)
{
    using var client = new HttpClient();
    return await client.GetStringAsync(url);
}
В.11 Організація через простори імен
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V11.cs

namespace MyApp.Models
{
    public class Order { /* ... */ }
}

namespace MyApp.Services
{
    public class OrderService { /* ... */ }
}

В.12 Абстракція для тестування
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V12.cs

       public class Order
       {
           public int Id { get; set; }
           public DateTime OrderDate { get; set; }
           public decimal Total { get; set; }
       }
       
В.13 Джуновський підхід
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V13.cs

public class OrderService
{
    public decimal SumCurrentMonthOrders(List<Order> orders)
    {
        decimal sum = 0m;
        foreach (var o in orders)
        {
            if (o.OrderDate.Month == DateTime.Now.Month)
            {
                sum += o.Total;
            }
        }
        return sum;
    }
}

В.14 Сеньйорський підхід
GitHub репозиторій: https://github.com/NureTatkovOleksandr/ark-pzpi-23-10-
tatkov-oleksandr/blob/main/Pract1/ark-pzpi-23-10-tatkov-oleksandr-pract1/V14.cs

	public interface IDateTimeProvider
{
    DateTime Now { get; }
}

public class SystemDateTimeProvider : IDateTimeProvider
{
    public DateTime Now => DateTime.Now;
}

public class OrderService
{
    private readonly IDateTimeProvider _dateTimeProvider;

    public OrderService(IDateTimeProvider dateTimeProvider)
    {
        _dateTimeProvider = dateTimeProvider ?? throw new 
ArgumentNullException(nameof(dateTimeProvider));
    }

    /// <summary>
    /// Повертає суму Total для замовлень, дата яких — у тому самому 
місяці та році, що й поточна дата.
    /// </summary>
    public decimal SumOrdersInCurrentMonth(IEnumerable<Order> orders)
    {
        if (orders is null) throw new 
ArgumentNullException(nameof(orders));

        var now = _dateTimeProvider.Now;
        int currentYear = now.Year;
        int currentMonth = now.Month;

        decimal sum = 0m;

        foreach (var order in orders)
        {
            // Опціонально: перевірка, чи order не null
            if (order != null && order.OrderDate.Year == currentYear && 
order.OrderDate.Month == currentMonth)
            {
                sum += order.Total;
            }
        }

        return sum;
    }
}

